"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var path=_interopDefault(require("path")),fs=_interopDefault(require("fs")),filenamify=_interopDefault(require("filenamify")),makeDir=_interopDefault(require("make-dir")),chalk=_interopDefault(require("chalk")),readline=_interopDefault(require("readline")),util=_interopDefault(require("util")),gotBase=_interopDefault(require("got")),cookie=_interopDefault(require("cookie")),mime=_interopDefault(require("mime-types")),jsdom=require("jsdom"),crypto=_interopDefault(require("crypto")),yargs=_interopDefault(require("yargs")),globby=_interopDefault(require("globby"));class Base{constructor(e={}){e=Object.assign({},e),Object.defineProperties(this,{props:{writable:!0,value:e}})}async setProps(e,t=!1){if("object"!=typeof e)return;const r=this.props;if(await this.shouldUpdate(r,e)){const s=async()=>{await this.willUpdate(r,e),this.props=Object.assign({},this.props,e),await this.update(),await this.didUpdate()};if(t)return s;await s()}else this.props=Object.assign({},r,e)}shouldUpdate(e,t){return!1}willUpdate(e,t){}update(){}didUpdate(){}}class FileInfo{constructor(e){const{chapter:t}=e;Object.defineProperties(this,{chapter:{value:t},integrity:{enumerable:!0,value:e.integrity},fname:{enumerable:!0,value:e.fname},buffer:{writable:!0,value:e.buffer}})}get relative(){return path.join(this.chapter.dirRelative,this.fname)}get absolute(){return path.join(this.chapter.dirAbsolute,this.fname)}exists(){try{return fs.accessSync(this.absolute),!0}catch(e){return!1}}async write(e=!1){this.buffer&&("function"==typeof this.buffer&&(this.buffer=await this.buffer()),fs.writeFileSync(this.absolute,await this.buffer,{flag:e?"w":"wx"}))}remove(e=!1){const{relative:t}=this;t.length>0&&"string"==typeof t&&fs.unlinkSync(this.absolute)}}class Chapter extends Base{constructor(e){super(e),this.props.files=e.files&&e.files.map((e,t)=>new FileInfo(Object.assign({},e,{chapter:this}))),Object.defineProperties(this,{index:{get:()=>this.props.index},title:{enumerable:!0,get:()=>this.props.title},files:{enumerable:!0,get:()=>this.props.files},integrity:{enumerable:!0,get:()=>this.props.integrity},volume:{enumerable:!0,get:()=>{let e=this.props.volume&&this.props.volume.index;if(Number.isInteger(e))return e}}})}getName(e){return filenamify(`${this.prefix} ${e}`)}get prefix(){return`${this.props.index.toString().padStart(3,"0")}`}get dirRelative(){const{volume:e}=this.props;return e?e.relative:""}get dirAbsolute(){const{volume:e}=this.props;return e?e.absolute:this.props.base?this.props.base:process.cwd()}async shouldUpdate(e,t){{let e=Object.getOwnPropertyNames(t);if(1===e.length&&"files"===e[0])return!1}if(t.integrity&&t.integrity!==e.integrity)return!0;if(t.index&&t.index!==e.index)return!0;if(e.files){for(const t of e.files)if(!await t.exists())return!0;if(t.files)for(const[r,s]of e.files.entries()){const e=t.files[s];if(r.integrity!==e.integrity)return!0;if(r.fname!==e.fname)return!0}}return!1}async willUpdate(e,t){super.willUpdate(...arguments);const r=this.props.files;makeDir.sync(this.dirAbsolute),r&&await Promise.all(r.map(e=>{try{e.remove()}catch(e){}}))}update(){const{props:e}=this,t=[new FileInfo({chapter:this,fname:this.getName(`${e.title}.txt`),integrity:void 0})];e.files=t}async didUpdate(){const{props:e}=this,{files:t}=e;if(!t)return;return makeDir.sync(this.dirAbsolute),Promise.all(t.map(t=>{if(t.buffer)return t.write(e.overwrite)}))}printInfo(){const{props:e}=this,{files:t}=e;console.log(chalk`  {gray ${this.prefix}} ${e.title}{green ${t.length>1?" +"+(t.length-1):""}}`)}}class Volume extends Base{constructor(e){super(e),Object.defineProperties(this,{index:{get:()=>this.props.index},title:{enumerable:!0,get:()=>this.props.title}})}get base(){const{props:e}=this;return e.base?path.resolve(e.base):process.cwd()}get filename(){const{props:e}=this;return filenamify(`${e.index.toString().padStart(2,"0")} ${e.title}`)}get relative(){return this.filename}get absolute(){return path.resolve(this.base,this.relative)}}const clearLine=()=>{readline.clearLine(process.stdout,0),readline.cursorTo(process.stdout,0)},print=(...e)=>{process.stdout.write(util.format(...e))},log=(...e)=>console.log(...e);class Series extends Base{constructor(e,t=!1){if(super(t?e:Series.parseMeta(e)),(e=this.props).volumes){const{Volume:t}=this;e.volumes=e.volumes.map((e,r)=>new t(Object.assign({},e,{index:r,base:this.targetDir})))}else e.volumes=[];if(e.chapters){const{Chapter:t}=this;e.chapters=e.chapters.map((r,s)=>{let i=Number.isInteger(r.volume)&&e.volumes[r.volume];return new t(Object.assign({},r,{index:s,volume:i}))})}else e.chapters=[];Object.defineProperties(this,{sourceURL:{enumerable:!0,get:()=>this.props.sourceURL},volumes:{enumerable:!0,get:()=>this.props.volumes.length&&this.props.volumes||void 0},chapters:{enumerable:!0,get:()=>this.props.chapters.length&&this.props.chapters||void 0}})}get Chapter(){return Chapter}get Volume(){return Volume}get targetDir(){return path.resolve(this.props.targetDir)}shouldLog(e){return this.props.verbose&&this.props.verbose>=e}static parseMeta(e){let t={verbose:e.verbose&&(parseInt(e.verbose)||1),overwrite:e.overwrite};try{let r=new URL(e.source),s=e.name||filenamify(`${r.host}${r.pathname}`),i=path.resolve(e.chdir||"",s),n={};try{let e=path.join(i,"index.json"),t=JSON.parse(fs.readFileSync(e,"utf8"));Object.assign(n,t)}catch(e){}return Object.assign(n,{sourceURL:r,targetDir:i},t)}catch(r){try{let r=path.resolve(path.join(e.source,"index.json")),s=JSON.parse(fs.readFileSync(r,"utf8")),i=path.dirname(r);return s.sourceURL=new URL(s.sourceURL),Object.assign(s,{targetDir:i},t)}catch(e){throw new Error("Failed to read index.json")}}}shouldUpdate(){return!0}async willUpdate(e,t){const{props:r,Volume:s,Chapter:i}=this,{volumes:n,chapters:o}=t;if(n&&(t.volumes=await Promise.all(n.map(async(e,t)=>{let i=r.volumes[t]&&r.volumes[t].props||{},n=new s(Object.assign(i,{index:t,base:this.targetDir}));return await n.setProps(Object.assign({},e,{index:t})),n}))),o){const e=[];t.chapters=await Promise.all(o.map(async(s,n)=>{let o=Number.isInteger(s.volume)&&t.volumes[s.volume],a=r.chapters[n]&&r.chapters[n].props||{},l=new i(Object.assign(a,{index:n,base:this.targetDir,overwrite:r.overwrite})),p=await l.setProps(Object.assign({},s,{index:n,volume:o,base:this.targetDir}),!0);return p&&e.push([l,p]),l})),t.defers=e,t.delta=o.length-(r.chapters&&r.chapters.length||0)}return super.willUpdate(e,t)}async saveIndex(){const e=path.join(this.props.targetDir,"index.json");fs.writeFileSync(e,JSON.stringify(this,null,1),"utf8")}async update(){const{props:e}=this,t=path.join(e.targetDir,"index.json");if(await makeDir(e.targetDir),fs.writeFileSync(t,JSON.stringify(this,null,1),"utf8"),e.defers&&e.defers.length){const t=this.shouldLog(1),r=e.defers.length,s=e.defers.length>16;if(t&&(print(chalk`  {green [${e.chapters.length}]} {green ->} `),e.delta&&print(chalk`{green New ${e.delta}}{gray ,} `),log(chalk`{red Updated ${e.defers.length}}`)),s){for(const[s,[,i]]of e.defers.entries())await i(),await this.saveIndex(),t&&(clearLine(),print(chalk`  {green ->} {gray [${s+1}/${r}]}`));t&&(clearLine(),log(chalk`  {gray [${r}/${r}]}`))}else for(const[r,[s,i]]of e.defers.entries())await i(),t&&await s.printInfo(),await this.saveIndex();this.saveIndex(),t&&log(chalk`  {green Completed}`),delete e.defers,delete e.delta}}async refresh(){if(this.shouldLog(1)){const e=process.stdout.columns;let t=path.relative(".",this.targetDir),r=6+String(this.sourceURL).length+t.length;print(chalk`{gray #} {blue ${this.sourceURL}}`),r>e?log():print(" "),log(chalk`{green ->} ${t}`)}return this.fetch()}async fetch(){}}const got=(e,t={})=>(t.headers=Object.assign({},t.headers),/^novel18./.test(e.hostname)&&(t.headers.cookie=cookie.serialize("over18","yes")),gotBase(e,t)),hash=e=>{return crypto.createHash("sha256").update(e,"utf8").digest("base64")};class Chapter$1 extends Chapter{async update(){const{props:e}=this;if(delete e.files,e.buffer&&!e.doc)return void(e.files=[new FileInfo({chapter:this,fname:this.getName(`${e.title}.txt`),integity:void 0,buffer:e.buffer})]);let t=e.doc;if(!t){if(!e.sourceURL)return;t=await(async()=>{let{window:{document:t}}=new jsdom.JSDOM((await got(e.sourceURL)).body,{url:e.sourceURL});return t})()}let r=[],s=[];for(const e of t.querySelectorAll("#novel_color img")){let r=t.createTextNode(`![](${e.src})`);e.parentNode.replaceChild(r,e),s.push(e.src)}{const s=await e.buffer;let i=s?"function"==typeof s?await s():s.toString():"";const n=[".novel_subtitle","#novel_p","#novel_honbun","#novel_a"];for(const e of n)for(const r of t.querySelectorAll(e))i+=r.textContent+"\n\n-----\n\n";r.push(new FileInfo({chapter:this,fname:this.getName(`${e.title}.txt`),integity:void 0,buffer:i}))}{let e=s.map(async(e,t)=>{let{body:r,headers:s}=await got(e,{encoding:null});return{chapter:this,fname:`${this.prefix} image ${String(t+1).padStart(2,"0")}.${mime.extension(s["content-type"])||"jpg"}`,integrity:e,buffer:r}});s=await Promise.all(e);for(const e of s)r.push(new FileInfo(e))}e.files=r}}class Volume$1 extends Volume{}class Series$1 extends Series{constructor(e,...t){if(super(e,...t),!Series$1.test(this.sourceURL))throw new Error("Invalid URL")}static test(e){return/^((http|https):\/\/|)(ncode|novel18).syosetu.com\/[^\/]+\/?$/.test(e)}get Chapter(){return Chapter$1}get Volume(){return Volume$1}async fetch(){const e=this.sourceURL;let{window:{document:t}}=new jsdom.JSDOM((await got(e)).body,{url:e}),r=[],s=[],i="";{const e=t.querySelector(".novel_title").textContent.trim(),r=t.querySelector(".novel_writername").textContent.trim().substr("作者：".length);i=`# ${e}\nAuthor: ${r}\n\n`;let n=!1;{let e=t.querySelector("#novel_ex");null!=e?i+=e.textContent:n=!0,i+="\n\n-----\n\n"}s.push({title:"Description",integrity:Date.now(),buffer:()=>i,doc:n?t:void 0})}let n=-1,o=t.querySelector(".index_box");if(null==o)return this.setProps({chapters:s});let a=[];for(const t of o.children)if(t.classList.contains("chapter_title")){let e=t.textContent.trim();r.push({title:e}),i+=`\n## ${e}\n`,++n}else if(t.classList.contains("novel_sublist2")){let r=Number(n);a.push((async()=>{let{textContent:s,href:n}=(()=>{let e=t.firstElementChild.firstElementChild;return"a"!==e.nodeName.toLowerCase()&&(e=t.querySelector("a")),e})();return s=s.trim(),i+=`${String(a.length+1).padStart(3,"0")} ${s}\n`,n.startsWith("//")?n=e.protocol+n:n.startsWith("/")&&(n=new URL(n,e.origin)),{volume:r,sourceURL:n,title:s,integrity:(()=>{let e=(()=>{let e=t.lastElementChild;return e.classList.contains("long_update")?e:t.querySelector(".long_update")})(),r=e.lastElementChild;return r?r.title.trim():e.innerHTML.trim()})()}})())}s[0].integrity=hash(i),s=s.concat(await Promise.all(a)),await this.setProps({volumes:r,chapters:s})}}const engines=[Series$1];var getEngine=e=>{const t=Series.parseMeta(e),r=(()=>{for(const e of engines)if(e.test(t.sourceURL))return new e(t,!0)})();if(!r)throw new Error("Failed to find a matching engine");return r},name="translator-js",version="3.0.0",description="Scripts to support novel translation",main="src/index.js",repository="git@github.com:dino-absoluto/translator-js.git",author="Dino",license="GPL-3.0",scripts={standard:"standard",test:"jest",get:"node src/get.js"},dependencies={chalk:"^2.3.2",cookie:"^0.3.1",filenamify:"^2.1.0",globby:"^8.0.1",got:"^9.2.2",jsdom:"^12.1.0","make-dir":"^1.3.0","mime-types":"^2.1.20",yargs:"^12.0.2"},devDependencies={"@babel/core":"^7.1.2","@babel/preset-env":"^7.1.0","@babel/register":"^7.0.0","babel-core":"^7.0.0-bridge.0","babel-jest":"^23.6.0","builtin-modules":"^3.0.0",del:"^3.0.0",gulp:"^4.0.0",jest:"^23.6.0",rollup:"^0.66.6","rollup-plugin-babel":"^4.0.3","rollup-plugin-commonjs":"^9.2.0","rollup-plugin-json":"^3.1.0","rollup-plugin-node-resolve":"^3.4.0","rollup-plugin-terser":"^3.0.0",standard:"^12.0.1"},eslintConfig={extends:["standard"]},babel={presets:[["@babel/env",{useBuiltIns:"entry",targets:{node:!0}}]]},jest={roots:["<rootDir>/src/","<rootDir>/tests/"],transform:{"^.+\\.(js|mjs|jsx)$":"babel-jest"},testMatch:["**/?(*.)+(spec|test).(js|mjs|jsx)"],moduleFileExtensions:["js","mjs","json","jsx","node"]},_package={name:name,version:version,description:description,main:main,repository:repository,author:author,license:license,private:!0,scripts:scripts,dependencies:dependencies,devDependencies:devDependencies,eslintConfig:eslintConfig,babel:babel,jest:jest},_package$1=Object.freeze({name:name,version:version,description:description,main:main,repository:repository,author:author,license:license,scripts:scripts,dependencies:dependencies,devDependencies:devDependencies,eslintConfig:eslintConfig,babel:babel,jest:jest,default:_package});function getCjsExportFromNamespace(e){return e&&e.default||e}var require$$0=getCjsExportFromNamespace(_package$1);const config={version:require$$0.version,sourceDir:__dirname};var config_1=config;const report=e=>{console.error(chalk`{red ${report.stack?e.stack:e}}`),report.pedantic&&process.exit(-1)};report.pedantic=!0;const _postParse=e=>{report.stack=!!e.stack,report.pedantic=!!e.pedantic},_glob=async e=>{if(e.sources&&e.sources.length)return;let t=await globby(path.join(e.output,"**/index.json"));e.sources=t.map(e=>path.dirname(e))},_get=async e=>{let t=e.output||"./download/";for(const r of e.sources)try{let s=getEngine({source:r,verbose:!0,chdir:t,overwrite:e.force});await s.refresh()}catch(e){report(e),process.exit(-1)}},cmdGet=async e=>{await _postParse(e),await _glob(e),await _get(e)},_parseArgs=async()=>yargs.strict(!0).usage("$0 get [--output=<path>] [options] [<URL> | <path> ...]").help("help").alias("help","h").version(config_1.version).group(["help","version"],"Info:").option("stack",{hidden:!0,default:!1,type:"boolean"}).option("output",{alias:["o"],default:"download",type:"string",desc:"Output directory"}).option("force",{alias:["f"],default:!1,type:"boolean",desc:"Overwrite untracked files"}).option("pedantic",{default:!0,type:"boolean",desc:"Exit on first error"}).command("get [<sources>..]","Get RAWs",e=>e.strict().argv,cmdGet).demandCommand(1).fail(e=>{yargs.showHelp(),report(e)}).argv,_main=async()=>{await _parseArgs()};_main().catch(report);
//# sourceMappingURL=app.min.js.map
