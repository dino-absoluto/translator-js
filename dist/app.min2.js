"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var path=_interopDefault(require("path")),fs=_interopDefault(require("fs")),filenamify=_interopDefault(require("filenamify")),makeDir=_interopDefault(require("make-dir")),chalk=_interopDefault(require("chalk")),readline=_interopDefault(require("readline")),util=_interopDefault(require("util")),gotBase=_interopDefault(require("got")),cookie=_interopDefault(require("cookie")),mime=_interopDefault(require("mime-types")),jsdom=require("jsdom"),crypto=_interopDefault(require("crypto"));class Patch{constructor(e={}){e=Object.assign({},e),Object.defineProperties(this,{props:{writable:!0,value:e}})}async patch(e,t=!0){if("object"!=typeof e)return;let r=new this.constructor(Object.assign({},this.props,{last:this,patch:e}));return t&&await r.run(),r}async run(){const{props:e}=this,{last:t,patch:r}=e;delete e.last,delete e.patch,r&&(await this.shouldUpdate(t,r)?(await this.willUpdate(t,r),this.props=Object.assign({},this.props,r),await this.update(t),await this.didUpdate()):this.props=Object.assign({},this.props,r))}async isPending(){const{props:e}=this;return!(!e.patch||!await this.shouldUpdate(e.last,e.patch))}shouldUpdate(e,t){return!(!t||0===Object.getOwnPropertyNames(t).length)}willUpdate(e,t){}update(e){}didUpdate(){}}class FileInfo{constructor(e){const{chapter:t}=e;Object.defineProperties(this,{chapter:{value:t},integrity:{enumerable:!0,value:e.integrity},fname:{enumerable:!0,value:e.fname},buffer:{writable:!0,value:e.buffer}})}get relative(){return path.join(this.chapter.dirRelative,this.fname)}get absolute(){return path.join(this.chapter.dirAbsolute,this.fname)}exists(){try{return fs.accessSync(this.absolute),!0}catch(e){return!1}}async write(e=!1){this.buffer&&("function"==typeof this.buffer&&(this.buffer=await this.buffer()),fs.writeFileSync(this.absolute,await this.buffer,{flag:e?"w":"wx"}))}remove(e=!1){const{relative:t}=this;t.length>0&&"string"==typeof t&&fs.unlinkSync(this.absolute)}}class Chapter extends Patch{constructor(e){super(e),this.props.files=e.files&&e.files.map((e,t)=>new FileInfo(Object.assign({},e,{chapter:this}))),Object.defineProperties(this,{index:{get:()=>this.props.index},title:{enumerable:!0,get:()=>this.props.title},files:{enumerable:!0,get:()=>this.props.files},integrity:{enumerable:!0,get:()=>this.props.integrity},volume:{enumerable:!0,get:()=>{let e=this.props.volume&&this.props.volume.index;if(Number.isInteger(e))return e}}})}getName(e){return filenamify(`${this.prefix} ${e}`)}get prefix(){return`${this.props.index.toString().padStart(3,"0")}`}get dirRelative(){const{volume:e}=this.props;return e?e.relative:""}get dirAbsolute(){const{volume:e}=this.props;return e?e.absolute:this.props.base?this.props.base:process.cwd()}async shouldUpdate(e,t){{let e=Object.getOwnPropertyNames(t);if(1===e.length&&"files"===e[0])return!1}if(t.integrity&&t.integrity!==e.integrity)return!0;if(t.index&&t.index!==e.index)return!0;if(e.files){for(const t of e.files)if(!await t.exists())return!0;if(t.files)for(const[r,s]of e.files.entries()){const e=t.files[s];if(r.integrity!==e.integrity)return!0;if(r.fname!==e.fname)return!0}}return!1}async willUpdate(e,t){super.willUpdate(...arguments);const r=this.props.files;makeDir.sync(this.dirAbsolute),r&&await Promise.all(r.map(e=>{try{e.remove()}catch(e){}}))}update(){const{props:e}=this,t=[{fname:this.getName(`${e.title}.txt`),integrity:void 0}];e.files=t}async didUpdate(){const{props:e}=this;if(!e.files)return;e.files=e.files.map(e=>new FileInfo(Object.assign({},e,{chapter:this},e)));const{files:t}=e;return makeDir.sync(this.dirAbsolute),Promise.all(t.map(t=>{if(t.buffer)return t.write(e.overwrite)}))}printInfo(){const{props:e}=this,{files:t}=e;console.log(chalk`  {gray ${this.prefix}} ${e.title}{green ${t.length>1?" +"+(t.length-1):""}}`)}}class Volume extends Patch{constructor(e){super(e),Object.defineProperties(this,{index:{get:()=>this.props.index},title:{enumerable:!0,get:()=>this.props.title}})}get base(){const{props:e}=this;return e.base?path.resolve(e.base):process.cwd()}get filename(){const{props:e}=this;return filenamify(`${e.index.toString().padStart(2,"0")} ${e.title}`)}get relative(){return this.filename}get absolute(){return path.resolve(this.base,this.relative)}}const clearLine=()=>{readline.clearLine(process.stdout,0),readline.cursorTo(process.stdout,0)},print=(...e)=>{process.stdout.write(util.format(...e))},log=(...e)=>console.log(...e);class Series extends Patch{constructor(e,t=!1){if(super((t=t||e.last&&e.patch)?e:Series.parseMeta(e)),(e=this.props).volumes){const{Volume:t}=this;e.volumes=e.volumes.map((e,r)=>new t(Object.assign({},e,{index:r,base:this.targetDir})))}else e.volumes=[];if(e.chapters){const{Chapter:t}=this;e.chapters=e.chapters.map((r,s)=>{let i=Number.isInteger(r.volume)&&e.volumes[r.volume];return new t(Object.assign({},r,{index:s,volume:i}))})}else e.chapters=[];Object.defineProperties(this,{sourceURL:{enumerable:!0,get:()=>this.props.sourceURL},volumes:{enumerable:!0,get:()=>this.props.volumes.length&&this.props.volumes||void 0},chapters:{enumerable:!0,get:()=>this.props.chapters.length&&this.props.chapters||void 0}})}get Chapter(){return Chapter}get Volume(){return Volume}get targetDir(){return path.resolve(this.props.targetDir)}shouldLog(e){return this.props.verbose&&this.props.verbose>=e}static parseMeta(e){let t={verbose:e.verbose&&(parseInt(e.verbose)||1),overwrite:e.overwrite,last:e.last,patch:e.patch};try{let r=new URL(e.source),s=e.name||filenamify(`${r.host}${r.pathname}`),i=path.resolve(e.chdir||"",s),n={};try{let e=path.join(i,"index.json"),t=JSON.parse(fs.readFileSync(e,"utf8"));Object.assign(n,t)}catch(e){}return Object.assign(n,{sourceURL:r,targetDir:i},t)}catch(r){try{let r=path.resolve(path.join(e.source,"index.json")),s=JSON.parse(fs.readFileSync(r,"utf8")),i=path.dirname(r);return s.sourceURL=new URL(s.sourceURL),Object.assign(s,{targetDir:i},t)}catch(e){throw e}}}shouldUpdate(){return!0}async willUpdate(e,t){const{props:r,Volume:s,Chapter:i}=this,{volumes:n,chapters:a}=t;if(n&&(t.volumes=await Promise.all(n.map(async(e,t)=>{let i=r.volumes[t]&&r.volumes[t].props||{},n=new s(Object.assign(i,{index:t,base:this.targetDir}));return n=await n.patch(Object.assign({},e,{index:t}))}))),a){const e=[];t.chapters=await Promise.all(a.map(async(s,n)=>{let a=Number.isInteger(s.volume)&&t.volumes[s.volume],o=r.chapters[n]&&r.chapters[n].props||{},l=new i(Object.assign(o,{index:n,volume:a,base:this.targetDir,overwrite:r.overwrite}));return l=await l.patch(Object.assign({},s,{index:n,volume:a,base:this.targetDir}),!1),await l.isPending()?e.push([l,()=>l.run()]):await l.run(),l})),t.defers=e,t.delta=a.length-(r.chapters&&r.chapters.length||0)}return super.willUpdate(e,t)}async saveIndex(){const e=path.join(this.props.targetDir,"index.json");fs.writeFileSync(e,JSON.stringify(this,null,1),"utf8")}async update(){const{props:e}=this,t=path.join(e.targetDir,"index.json");if(await makeDir(e.targetDir),fs.writeFileSync(t,JSON.stringify(this,null,1),"utf8"),e.defers&&e.defers.length){const t=this.shouldLog(1),r=e.defers.length,s=e.defers.length>16;if(t&&(print(chalk`  {green [${e.chapters.length}]} {green =>} `),e.delta&&print(chalk`{green New ${e.delta}}{gray ,} `),log(chalk`{red Updated ${e.defers.length}}`)),s){for(const[s,[,i]]of e.defers.entries())await i(),await this.saveIndex(),t&&(clearLine(),print(chalk`  {green =>} {gray [${s+1}/${r}]}`));t&&(clearLine(),log(chalk`  {gray [${r}/${r}]}`))}else for(const[r,[s,i]]of e.defers.entries())await i(),t&&await s.printInfo(),await this.saveIndex();this.saveIndex(),t&&log(chalk`  {green Completed}`),delete e.defers,delete e.delta}}async refresh(){if(this.shouldLog(1)){const e=process.stdout.columns;let t=path.relative(".",this.targetDir),r=6+String(this.sourceURL).length+t.length;print(chalk`{gray #} {blue ${this.sourceURL}}`),r>e?log():print(" "),log(chalk`{green =>} ${t}`)}return this.fetch()}async fetch(){return this.patch({})}}const got=(e,t={})=>(t.headers=Object.assign({},t.headers),/^novel18./.test(e.hostname)&&(t.headers.cookie=cookie.serialize("over18","yes")),gotBase(e,t)),hash=e=>{return crypto.createHash("sha256").update(e,"utf8").digest("base64")};class Chapter$1 extends Chapter{async update(){const{props:e}=this,t=e.files;if(delete e.files,e.buffer&&!e.doc)return void(e.files=[{fname:this.getName(`${e.title}.txt`),integity:void 0,buffer:e.buffer}]);let r=e.doc;if(!r){if(!e.sourceURL)return;r=await(async()=>{let{window:{document:t}}=new jsdom.JSDOM((await got(e.sourceURL)).body,{url:e.sourceURL});return t})()}let s=[],i=[];for(const e of r.querySelectorAll("#novel_color img")){let t=r.createTextNode(`![](${e.src})`);e.parentNode.replaceChild(t,e),i.push(e.src)}{const t=await e.buffer;let i=t?"function"==typeof t?await t():t.toString():"";const n=[".novel_subtitle","#novel_p","#novel_honbun","#novel_a"];for(const e of n)for(const t of r.querySelectorAll(e))i+=t.textContent+"\n\n-----\n\n";s.push({fname:this.getName(`${e.title}.txt`),integity:void 0,buffer:i})}{let e=i.map(async(e,r)=>{const s=async()=>{let{body:t,headers:s}=await got(e,{encoding:null});return{content:t,fname:`${this.prefix} image ${String(r+1).padStart(2,"0")}.${mime.extension(s["content-type"])||"jpg"}`}};let i=t&&t[r+1];if(i&&i.fname&&i.integrity&&i.integrity===e)return{fname:i.fname,integrity:e,buffer:async()=>(await s()).content};let{fname:n,content:a}=await s();return{fname:n,integrity:e,buffer:a}});i=await Promise.all(e);for(const e of i)s.push(e)}e.files=s}}class Volume$1 extends Volume{}class Series$1 extends Series{constructor(e,...t){if(super(e,...t),!Series$1.test(this.sourceURL))throw new Error("Invalid URL")}static test(e){return/^((http|https):\/\/|)(ncode|novel18).syosetu.com\/[^\/]+\/?$/.test(e)}get Chapter(){return Chapter$1}get Volume(){return Volume$1}async fetch(){const e=this.sourceURL;let{window:{document:t}}=new jsdom.JSDOM((await got(e)).body,{url:e}),r=[],s=[],i="";{const e=t.querySelector(".novel_title").textContent.trim(),r=t.querySelector(".novel_writername").textContent.trim().substr("作者：".length);i=`# ${e}\nAuthor: ${r}\n\n`;let n=!1;{let e=t.querySelector("#novel_ex");null!=e?i+=e.textContent:n=!0,i+="\n\n-----\n\n"}s.push({title:"Description",integrity:Date.now(),buffer:()=>i,doc:n?t:void 0})}let n=-1,a=t.querySelector(".index_box");if(null==a)return this.setProps({chapters:s});let o=[];for(const t of a.children)if(t.classList.contains("chapter_title")){let e=t.textContent.trim();r.push({title:e}),i+=`\n## ${e}\n`,++n}else if(t.classList.contains("novel_sublist2")){let r=Number(n);o.push((async()=>{let{textContent:s,href:n}=(()=>{let e=t.firstElementChild.firstElementChild;return"a"!==e.nodeName.toLowerCase()&&(e=t.querySelector("a")),e})();return s=s.trim(),i+=`${String(o.length+1).padStart(3,"0")} ${s}\n`,n.startsWith("//")?n=e.protocol+n:n.startsWith("/")&&(n=new URL(n,e.origin)),{volume:r,sourceURL:n,title:s,integrity:(()=>{let e=(()=>{let e=t.lastElementChild;return e.classList.contains("long_update")?e:t.querySelector(".long_update")})(),r=e.lastElementChild;return r?r.title.trim():e.innerHTML.trim()})()}})())}return s[0].integrity=hash(i),s=s.concat(await Promise.all(o)),this.patch({volumes:r,chapters:s})}}const engines=[Series$1];var index=e=>{const t=Series.parseMeta(e),r=(()=>{for(const e of engines)if(e.test(t.sourceURL))return new e(t,!0)})();if(!r)throw new Error("Failed to find a matching engine");return r};module.exports=index;
//# sourceMappingURL=app.min2.js.map
